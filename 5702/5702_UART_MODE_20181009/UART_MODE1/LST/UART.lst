C51 COMPILER V9.56.0.0   UART                                                              09/30/2018 15:04:40 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Output\UART.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SRC\UART.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\SRC) DEBUG OBJECTEXTEND PRI
                    -NT(.\LST\UART.lst) TABS(2) OBJECT(.\Output\UART.obj)

line level    source

   1          #include "UART.h"                     
   2          #include "Timer0.h"
   3          
   4          
   5          bit f_rx = 0;                                                             //正在接收标志位
   6          idata uint8_t r_uart_rx_length = 0;                                       //该笔数据接收的长度
   7          idata uint8_t r_uart_rx_lengthbuf = 0;                                    //接收数据缓存buf,用于判断是否接收
             -成
   8          idata uint8_t r_urat_rx_data[L_RX_LENGTH] = {0};                          //接收到的数据缓存
   9          idata uint8_t r_urat_tx_data[L_TX_LENGTH] = {0};                          //发生数据缓存,该Demo中未使用
  10          
  11          //========================================================================================================
             -=====//
  12          // UART init
  13          //========================================================================================================
             -=====//
  14          void UART1init(void)
  15          {
  16   1        P05 = 1;
  17   1        P0M |= 0x20;                                  //UTX初始化输出高 
  18   1        P0M &= 0xbf;                                  //URX初始化数模模式
  19   1        
  20   1        SM0 = 0;                                      //模式1
  21   1        SM1 = 1;
  22   1        REN0 = 1;                                     //使能接收功能
  23   1        switch (L_BRUD_RATE)                          //波特率设置
  24   1        {
  25   2          case L_BRUD_RATE_4800:
  26   2               PCON &= 0x7f;                                
  27   2               BD = 1;        
  28   2               S0RELH = L_S0RELH_4800;
  29   2               S0RELL = L_S0RELL_4800;                  
  30   2            break;    
  31   2          case L_BRUD_RATE_9600:
  32   2               PCON &= 0x7f;                                
  33   2               BD = 1;        
  34   2               S0RELH = L_S0RELH_9600;
  35   2               S0RELL = L_S0RELL_9600;                  
  36   2            break;
  37   2          case L_BRUD_RATE_19200:
  38   2               PCON &= 0x7f;                                
  39   2               BD = 1;        
  40   2               S0RELH = L_S0RELH_19200;
  41   2               S0RELL = L_S0RELL_19200;                     
  42   2            break;
  43   2          case L_BRUD_RATE_38400:
  44   2               PCON &= 0x7f;                                
  45   2               BD = 1;        
  46   2               S0RELH = L_S0RELH_38400;
  47   2               S0RELL = L_S0RELL_38400;                     
  48   2            break;
  49   2          case L_BRUD_RATE_56000:
  50   2               PCON |= 0x80; 
  51   2               BD = 1;    
C51 COMPILER V9.56.0.0   UART                                                              09/30/2018 15:04:40 PAGE 2   

  52   2               S0RELH = L_S0RELH_56000;
  53   2               S0RELL = L_S0RELL_56000;                                                       
  54   2            break;
  55   2          case L_BRUD_RATE_57600:
  56   2               PCON |= 0x80;   
  57   2               BD = 1;      
  58   2               S0RELH = L_S0RELH_57600;
  59   2               S0RELL = L_S0RELL_57600;                                               
  60   2            break;
  61   2          case L_BRUD_RATE_115200:
  62   2               PCON |= 0x80;  
  63   2               BD = 1;      
  64   2               S0RELH = L_S0RELH_115200;
  65   2               S0RELL = L_S0RELL_115200;                                                  
  66   2            break;
  67   2          case L_BRUD_RATE_128000:
  68   2               PCON |= 0x80;                                
  69   2               BD = 1;        
  70   2               S0RELH = L_S0RELH_128000;
  71   2               S0RELL = L_S0RELL_128000;                      
  72   2            break;  
  73   2          case L_BRUD_RATE_250000:
  74   2               PCON |= 0x80;                                
  75   2               BD = 1;      
  76   2               S0RELH = L_S0RELH_250000;
  77   2               S0RELL = L_S0RELL_250000;                        
  78   2            break;      
  79   2          default:
  80   2            break;
  81   2        }
  82   1        ES0 = 1;                                            //使能UART中断
  83   1      }
  84          
  85          //========================================================================================================
             -=====//
  86          // UART respond 若在接收状态,5ms判断一次数据是否接收完成,若接收完数据据后,将接
             -收到的数据数据再发生出去
  87          /* 该程序主要是UART 解码的一种思路,每5ms判断一次是否在接收状态,若是，在判断
             -r_uart_rx_length与r_uart_rx_lengthbuf
  88            是否相等,若相等则说明该帧数据接收完,则可以进行解码操作。若不相等,说明
             -据还未接收完。该解码思路仅供参考
  89          */
  90          //========================================================================================================
             -=====//
  91          void UARTrespond(void)
  92          {
  93   1        uint8_t i = 0;
  94   1        if(f_1ms == 1)
  95   1        {
  96   2          f_1ms = 0;
  97   2          if((--r_timer_5ms) == 0)                            
  98   2          {
  99   3            r_timer_5ms = L_TIMER_5MS;
 100   3            if(f_rx == 1)                                             //5ms判断一次是否在接收数据状态,该时间根据设置
             -波特率不同进行修改
 101   3            {
 102   4              if(r_uart_rx_length == r_uart_rx_lengthbuf)             //判断该帧数据是否接收完,若接收完
             -接收到的数据再发送出去    
 103   4              {
 104   5                f_rx = 0;
 105   5                for(i=0;i<r_uart_rx_length;i++)
 106   5                {
C51 COMPILER V9.56.0.0   UART                                                              09/30/2018 15:04:40 PAGE 3   

 107   6                  S0BUF = r_urat_rx_data[i];   
 108   6                  while(!TI0);                                        //等待发送完成
 109   6                  TI0 = 0;
 110   6                }
 111   5                r_uart_rx_length = 0;
 112   5                r_uart_rx_lengthbuf = 0;
 113   5              }
 114   4              else                                                    
 115   4              {
 116   5                r_uart_rx_lengthbuf = r_uart_rx_length; 
 117   5              }
 118   4            }
 119   3          }
 120   2        }
 121   1      }
 122          
 123          //========================================================================================================
             -=====//
 124          // UART ISR
 125          //========================================================================================================
             -=====//
 126          void UARTISR(void) interrupt ISRUart 
 127          {
 128   1        if(RI0 == 1)                                            //RI0软件清零
 129   1        {
 130   2          RI0 = 0;
 131   2          f_rx = 1;                                             //置接收标志位
 132   2          r_urat_rx_data[r_uart_rx_length++] = S0BUF;
 133   2        }
 134   1      }
 135          
 136          
 137          
 138          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    286    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     42    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
