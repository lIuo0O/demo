C51 COMPILER V9.56.0.0   I2C_MASTER                                                        12/16/2019 11:11:29 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE I2C_MASTER
OBJECT MODULE PLACED IN .\Objects\i2c_master.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\i2c_master.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\i2c_master.lst) TABS(2) OBJECT(.\Objects\i2c_master.obj)

line level    source

   1          #include "i2c_master.h"
   2          #include "string.h"
   3          /**************************************************************************************
   4                                Global Variables 
   5          ***************************************************************************************/
   6          bit     f_bI2cFlag = 0;
   7          bit     f_bI2cRxOk = 0;
   8          uint8_t g_cI2cDataBuf[MAX_BUF_LEN];
   9          uint8_t g_cI2cAddr = 0;
  10          uint8_t g_cI2cDataLen = 0;
  11          uint8_t g_cI2cBufSize = 0;
  12          /**************************************************************************************
  13          Function: set input pin
  14                    Set slave addr
  15                    I2C & Interrupt enable
  16          ***************************************************************************************/
  17          void i2c_master_init(void)
  18          {
  19   1        P0M &= 0xE7;
  20   1        P0UR |= 0x18;                          // set  SDA(P04) SCL(P03)  pin's at input mode
  21   1        
  22   1      //  I2CCON = 0x40;                       // I2C enable (ENS1),Fclk = Fcpu/256
  23   1        I2CCON = 0xC0;                         // I2C enable (ENS1),Fclk = Fcpu/960
  24   1      
  25   1        SMBSEL = 0x05;                         // Select the high byte of Tout Register.
  26   1        SMBDST = TIME_PERIOD >> 8;
  27   1        
  28   1        SMBSEL = 0x04;                         // Select the low byte of Tout Register
  29   1        SMBDST = TIME_PERIOD;                  // 35ms
  30   1        
  31   1        SMBSEL |= 0x80;                        // EnablE SMBus extension function 
  32   1        
  33   1        EI2C = 1;                              // I2C Interrupt enable
  34   1        EAL = 1;                               // Interrupt enable
  35   1      }
  36          /****************************************************************************************
  37          Function:   I2C Trasmit data
  38          input:      cWrDataAddr,p_cWrDataBuf,cNumByteToWrite
  39          Output:     None
  40          Return:     None
  41          ****************************************************************************************/
  42          void i2c_master_write_n_byte(uint8_t cWrDataAddr, uint8_t * p_cWrDataBuf, uint8_t cNumByteToWrite)
  43          {
  44   1        if(f_bI2cFlag == 0)
  45   1        {
  46   2          if (cNumByteToWrite > MAX_BUF_LEN)    
  47   2              return ;                                      // over buf Size
  48   2          
  49   2          if (cNumByteToWrite == 0)    
  50   2              return ;                                      // error Size
  51   2          
  52   2          f_bI2cFlag = 1;                                   // get Use Right
  53   2          g_cI2cDataLen = cNumByteToWrite;                  // set length                           
  54   2          g_cI2cAddr = (cWrDataAddr & 0xFE) | I2C_WRITE;    // write mode  
C51 COMPILER V9.56.0.0   I2C_MASTER                                                        12/16/2019 11:11:29 PAGE 2   

  55   2          
  56   2          memcpy(g_cI2cDataBuf, p_cWrDataBuf, cNumByteToWrite);
  57   2          
  58   2          I2CCON &= 0xF7;                                   // Clear I2C flag 
  59   2          I2CCON |= 0x20;                                   // START (STA) = 1
  60   2        }
  61   1      }
  62          
  63          /*****************************************************************************************
  64          Function:   I2C Receive data
  65          input:      cRdDataAddr,p_cRdDataBuf,cNumByteToWrite
  66          Output:     None
  67          Return:     None
  68          ******************************************************************************************/
  69          void i2c_master_read_n_byte (uint8_t cRdDataAddr, uint8_t * p_cRdDataBuf, uint8_t cNumByteToRead)
  70          {
  71   1        uint16_t iRetry  = 0;
  72   1        if(f_bI2cFlag == 0)
  73   1        {
  74   2          if (cNumByteToRead > MAX_BUF_LEN)    
  75   2            return ;                                      // over buf Size
  76   2          if (cNumByteToRead == 0)    
  77   2            return ;                                      // error Size
  78   2          
  79   2          f_bI2cRxOk = 0;
  80   2          f_bI2cFlag = 1;                                 // get Use Right
  81   2          
  82   2          g_cI2cDataLen = cNumByteToRead - 1;             // set length
  83   2          g_cI2cAddr = (cRdDataAddr & 0xFE) | I2C_READ;   // read mode
  84   2        
  85   2          I2CCON &= 0xF7;                                 // Clear I2C flag 
  86   2          I2CCON |= 0x20;                                 // START = 1
  87   2      
  88   2          while(!f_bI2cRxOk)
  89   2          {
  90   3            iRetry++;
  91   3            _nop_();
  92   3            WDTR = 0x5A;                                  // clear watchdog 
  93   3            if(iRetry >= WAIT_TIME)
  94   3            {
  95   4              return ;
  96   4            }
  97   3          }
  98   2          
  99   2          f_bI2cRxOk = 0;
 100   2          memcpy(p_cRdDataBuf, g_cI2cDataBuf, cNumByteToRead);
 101   2        }
 102   1      }
 103          /**************************************************************************************
 104          Function: I2C ISR Routine 
 105          ***************************************************************************************/
 106          void isr_i2c_master (void) interrupt ISRI2c                   
 107          {
 108   1        switch (I2CSTA)
 109   1        {
 110   2          // Master Transmit  Address
 111   2          case I2C_START:
 112   2          case I2C_RESTART:
 113   2          {
 114   3            I2CCON &= 0xCF;                             // Clear STOP & STA  
 115   3            I2CDAT = g_cI2cAddr;                        // Tx/Rx addr
 116   3            break;
C51 COMPILER V9.56.0.0   I2C_MASTER                                                        12/16/2019 11:11:29 PAGE 3   

 117   3          }
 118   2          
 119   2          // Master Transmit
 120   2          case I2C_MT_SLA_ACK:  
 121   2          {     
 122   3            g_cI2cBufSize = 0;
 123   3            
 124   3            I2CDAT = g_cI2cDataBuf[g_cI2cBufSize++];    // write first byte
 125   3            break;
 126   3          }
 127   2          case I2C_MT_DATA_ACK:                         // write n byte
 128   2          {
 129   3            if(g_cI2cBufSize >= g_cI2cDataLen)          // Last byte
 130   3            {                             
 131   4              I2CCON |= 0x10;                           // STOP 
 132   4              f_bI2cFlag = 0;                           // finish 
 133   4            }
 134   3            else
 135   3            {
 136   4              I2CDAT = g_cI2cDataBuf[g_cI2cBufSize++];
 137   4            }
 138   3            
 139   3            break;
 140   3          }
 141   2              
 142   2          // Master Receive 
 143   2          case I2C_MR_SLA_ACK:                          // get slave addr
 144   2          {
 145   3            g_cI2cBufSize = 0;
 146   3          
 147   3            I2CCON |= 0x04;                             // AA = 1
 148   3            break;
 149   3          }
 150   2          case I2C_MR_DATA_ACK:                         // read n byte
 151   2          {
 152   3            g_cI2cDataBuf[g_cI2cBufSize++] = I2CDAT; 
 153   3            
 154   3            I2CCON |= 0x04;                             // AA = 1
 155   3            if (g_cI2cBufSize >= g_cI2cDataLen)
 156   3            {
 157   4              I2CCON &= 0xFB;                           // AA = 0   
 158   4            }
 159   3            break;
 160   3          }
 161   2          case I2C_MR_DATA_NACK:  
 162   2          {
 163   3            g_cI2cDataBuf[g_cI2cBufSize] = I2CDAT; 
 164   3            
 165   3            I2CCON |= 0x10;                             // STOP   
 166   3            
 167   3            f_bI2cRxOk = 1;
 168   3            f_bI2cFlag = 0;                             // finish         
 169   3            break; 
 170   3          }
 171   2          default: 
 172   2          {
 173   3            I2CCON |= 0x10;                             // STOP   
 174   3      
 175   3            g_cI2cBufSize = 0;
 176   3            f_bI2cRxOk = 0;
 177   3            f_bI2cFlag = 0;                             // finish     
 178   3            break; 
C51 COMPILER V9.56.0.0   I2C_MASTER                                                        12/16/2019 11:11:29 PAGE 4   

 179   3          }
 180   2        }
 181   1        I2CCON &= 0xF7;                                 // Clear I2C flag         
 182   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    315    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
