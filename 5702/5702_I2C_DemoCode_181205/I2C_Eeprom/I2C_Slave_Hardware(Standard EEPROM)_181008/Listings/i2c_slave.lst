C51 COMPILER V9.54   I2C_SLAVE                                                             12/05/2018 13:25:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE I2C_SLAVE
OBJECT MODULE PLACED IN .\Objects\i2c_slave.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\i2c_slave.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\i2c_slave.lst) TABS(2) OBJECT(.\Objects\i2c_slave.obj)

line level    source

   1          #include "i2c_slave.h"
   2          /***************************************************************************
   3                                    Global Variable
   4          ***************************************************************************/
   5          bit f_bRxFlag = 0;
   6          bit f_bAddrFlag = 0;
   7          
   8          uint8_t g_cDataAddr = 0;
   9          uint8_t g_cI2cRamBuf[MAX_BUF_LEN];            // EEPROM ÄÚ´æ
  10          /**************************************************************************************
  11          Function: set input pin
  12                    Set slave addr
  13                    Interrupt enable
  14          ***************************************************************************************/
  15          void i2c_slave_init (void)
  16          { 
  17   1        P0M &= 0xE7;
  18   1        P0UR |= 0x18;                               // set  SDA(P04) SCL(P03)  pin's at input mode
  19   1        
  20   1      //  I2CCON = 0x40;                            // I2C enable (ENS1),Fclk = Fcpu/256
  21   1        I2CCON = 0xC0;                              // I2C enable (ENS1),Fclk = Fcpu/960
  22   1        
  23   1        SMBSEL = 0x05;                              // Select the high byte of Tout Register.
  24   1        SMBDST = TIME_PERIOD >> 8;
  25   1        
  26   1        SMBSEL = 0x04;                              // Select the low byte of Tout Register
  27   1        SMBDST = TIME_PERIOD;                       // 35ms
  28   1        
  29   1        SMBSEL |= 0x80;                             // EnablE SMBus extension function 
  30   1        
  31   1        EI2C = 1;                                   // I2C Interrupt enable
  32   1        EAL = 1;                                    // Interrupt enable
  33   1        
  34   1        I2CADR = I2C_SLAVE_ADDR;                    // init slave addr
  35   1        I2CCON |= 0x04;                             // AA = 1     
  36   1      }
  37          /**************************************************************************************
  38          Function: i2c_slave isr service
  39          ***************************************************************************************/
  40          void isr_i2c_slave (void) interrupt ISRI2c
  41          {
  42   1        switch(I2CSTA)
  43   1        {      
  44   2          //Slave Transmit
  45   2          case I2C_ST_SLA_ACK:
  46   2          case I2C_ST_DATA_ACK:   
  47   2          {
  48   3            I2CDAT = g_cI2cRamBuf[g_cDataAddr++];
  49   3            break;
  50   3          }
  51   2          
  52   2          //Slave Receive
  53   2          case I2C_SR_SLA_ACK:
  54   2          case I2C_SR_GCALL_ACK:
C51 COMPILER V9.54   I2C_SLAVE                                                             12/05/2018 13:25:42 PAGE 2   

  55   2          {
  56   3            I2CCON |= 0x04;                       // AA = 1 
  57   3            break;
  58   3          }
  59   2          case I2C_SR_DATA_ACK:
  60   2          case I2C_SR_GCALL_DATA_ACK: 
  61   2          {
  62   3            if(f_bAddrFlag == 0)
  63   3            {
  64   4              f_bAddrFlag = 1;                    // Set Data Address Flag      
  65   4              g_cDataAddr = I2CDAT;               // Receive Data Address
  66   4            }
  67   3            else
  68   3            {
  69   4              g_cI2cRamBuf[g_cDataAddr++] = I2CDAT;
  70   4            }
  71   3            break;      
  72   3          }
  73   2      
  74   2          default:
  75   2          {
  76   3            f_bAddrFlag = 0;                      // Clear
  77   3            I2CCON &= 0xCF;                       // Clear STA & STOP     
  78   3            break;    
  79   3          }     
  80   2        }
  81   1        
  82   1        I2CCON |= 0x04;                           // AA = 1 
  83   1        I2CCON &= 0xF7;                           // Clear I2C flag 
  84   1        
  85   1        if(g_cDataAddr >= MAX_BUF_LEN)
  86   1        {
  87   2          g_cDataAddr = 0;                        // Over Size
  88   2        }
  89   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    143    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
