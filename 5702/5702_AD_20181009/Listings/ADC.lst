C51 COMPILER V9.56.0.0   ADC                                                               01/07/2020 14:31:55 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\ADC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\ADC.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Source;.\Source) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\ADC.lst) TABS(2) OBJECT(.\Objects\ADC.obj)

line level    source

   1          #include "ADC.h"
   2          
   3          //========================================================================================================
             -=====//
   4          //            DATA
   5          //========================================================================================================
             -=====//
   6          idata uint16_t r_ad_value1 = 0;                           //滤波之后的AD值
   7          idata uint16_t r_ad_value2 = 0;                         
   8          idata uint16_t r_ad_value3 = 0;
   9          
  10          idata uint8_t r_ad1_cnt = 0;                              //滑动滤波寄存器                          
  11          idata uint8_t r_ad2_cnt = 0;
  12          idata uint8_t r_ad3_cnt = 0;
  13          
  14          idata uint16_t r_ad1_fifo[L_AD_SAMPLE_MAX] = 0;          //AD的fifo值
  15          idata uint16_t r_ad2_fifo[L_AD_SAMPLE_MAX] = 0;
  16          idata uint16_t r_ad3_fifo[L_AD_SAMPLE_MAX] = 0;
  17          
  18          //========================================================================================================
             -=====//
  19          //  AD 初始化
  20          //========================================================================================================
             -=====//
  21          void ADinit(void)
  22          {
  23   1        ADM |= 0x80;                                          //ADC Enable
  24   1        ADM |= L_AD_CHANNEL1;
  25   1        
  26   1        ADR = 0x40;                                         //AIN channel Enable
  27   1        ADR |= L_AD_SPEEDDIV16;
  28   1        
  29   1        VREFH = L_VREF_INT;             
  30   1        VREFH |= L_VERFH_4V;
  31   1        
  32   1        P1CON |= 0x0c;                                        // AD口使用需打开将P1CON的相应的位置1,否则漏电
  33   1      }
  34          
  35          //========================================================================================================
             -=====//
  36          //  AD 滑动滤波
  37          //========================================================================================================
             -=====//
  38          void  ADSample(void)
  39          {
  40   1      //外部AD通道,
  41   1      //===============================================================================// 
  42   1        r_ad1_fifo[r_ad1_cnt ++] = GetAD(L_AD_CHANNEL1);
  43   1        if(r_ad1_cnt == L_AD_SAMPLE_MAX) 
  44   1          r_ad1_cnt = 0;
  45   1        r_ad_value1 = ADAverge(r_ad1_fifo);
  46   1        
  47   1        r_ad2_fifo[r_ad2_cnt ++] = GetAD(L_AD_CHANNEL2);
  48   1        if(r_ad2_cnt == L_AD_SAMPLE_MAX) 
C51 COMPILER V9.56.0.0   ADC                                                               01/07/2020 14:31:55 PAGE 2   

  49   1          r_ad2_cnt = 0;
  50   1        r_ad_value2 = ADAverge(r_ad2_fifo);
  51   1      //===============================================================================// 
  52   1      
  53   1      //内部2V/3V/4V输入通道, 该通道的参考电压为VDD,输入检测通道为 2V/3V/4V(由VREFH Bit0,Bit1决定)
  54   1      //                                                                      VREFH   0   0    2V 输入通道
  55   1      //                                                                      VREFH   0   1    3V 输入通道
  56   1      //                                                                      VREFH   1   0    4V 输入通道
  57   1      //该通道根据IC内部的2V/3V/4V来求出VDD的电压,计算公式：VDD = 4096/r_ad_value3 *(2V/3V/4V) 
  58   1      //本Deno选择内部4V输入通道来计算VDD电压
  59   1      //===============================================================================// 
  60   1        VREFH |= L_VERFH_INTVDD;
  61   1        r_ad3_fifo[r_ad3_cnt ++] = GetAD(L_AD_CHANNEL3);
  62   1        if(r_ad3_cnt == L_AD_SAMPLE_MAX) 
  63   1          r_ad3_cnt = 0;
  64   1        r_ad_value3 = ADAverge(r_ad3_fifo); 
  65   1        VREFH &= (L_VERFH_INTVDD^0xff);
  66   1      }
  67          
  68          //========================================================================================================
             -=====//
  69          //  AD 滑动平均算法
  70          //========================================================================================================
             -=====//
  71          uint16_t ADAverge(uint16_t *ad_array)
  72          {
  73   1        uint8_t i = 0;
  74   1        uint16_t temp_sum = 0;
  75   1        
  76   1        for(i = 0;i < L_AD_SAMPLE_MAX;i++)
  77   1        {
  78   2          temp_sum += *(ad_array+i);
  79   2        }
  80   1        temp_sum = temp_sum >> L_AD_SHIFT;
  81   1        
  82   1        return temp_sum;
  83   1      }
  84          //=======================================================================
  85          //  AD 去极值平均
  86          //=======================================================================
  87          uint16_t GetAD(uint8_t  ad_channel)
  88          {   
  89   1        uint8_t i = 0;
  90   1        uint16_t j = 0;
  91   1        uint16_t temp_ad_max = 0;
  92   1        uint16_t temp_ad_min = 0xffff;
  93   1        uint16_t temp_ad_buf = 0;
  94   1        uint16_t temp_ad_data = 0;
  95   1        
  96   1        ADM = (ADM&0XF0)|ad_channel;
  97   1        
  98   1        for(i = 0; i < L_AD_SAMPLE_MAX + 2; i++)        
  99   1        {
 100   2          ADM |= 0x40;                          //Start ADC
 101   2          while((ADM & 0x20) != 0X20);          //EOC           
 102   2          ADM &= 0xdf;
 103   2          
 104   2          temp_ad_buf = ADB;
 105   2          temp_ad_buf = (temp_ad_buf << 4) + (ADR & 0X0F);
 106   2          temp_ad_data += temp_ad_buf; 
 107   2          
 108   2          if(temp_ad_buf < temp_ad_min)
C51 COMPILER V9.56.0.0   ADC                                                               01/07/2020 14:31:55 PAGE 3   

 109   2          {
 110   3            temp_ad_min = temp_ad_buf;
 111   3          }
 112   2          if(temp_ad_buf > temp_ad_max)
 113   2          {
 114   3            temp_ad_max = temp_ad_buf;
 115   3          } 
 116   2        }
 117   1        
 118   1        temp_ad_data = (temp_ad_data - temp_ad_min - temp_ad_max) >> L_AD_SHIFT;          
 119   1        return  temp_ad_data;
 120   1      }
 121          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    366    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =     57    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
